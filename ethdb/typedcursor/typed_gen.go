// Code generated by go generate; DO NOT EDIT.
package typedcursor

import (
	"bytes"
	"errors"

	"github.com/ledgerwatch/turbo-geth/ethdb"
	"github.com/ledgerwatch/turbo-geth/ethdb/cbor"
)

type Uint64 struct {
	ethdb.Cursor
}

func NewUint64(b ethdb.Cursor) *Uint64 {
	return &Uint64{b}
}

func (b *Uint64) Get(key []byte) (uint64, bool) {
	value, _ := b.Cursor.SeekExact(key)
	if value == nil {
		return 0, false
	}

	var v uint64
	decoder := cbor.Decoder(bytes.NewReader(value))
	defer cbor.Return(decoder)

	decoder.MustDecode(&v)
	return v, true
}

func (b *Uint64) Increment(key []byte) error {
	v, _ := b.Get(key)
	return b.Put(key, v+1)
}

func (b *Uint64) Decrement(key []byte) error {
	v, ok := b.Get(key)
	if !ok {
		// return ethdb.ErrNotFound
		return errors.New("not found key")
	}

	if v == 0 {
		return errors.New("could not decrement zero")
	}

	return b.Put(key, v-1)
}

func (b *Uint64) DecrementIfExist(key []byte) error {
	v, ok := b.Get(key)
	if !ok {
		return nil
	}

	if v == 0 {
		return errors.New("could not decrement zero")
	}

	return b.Put(key, v-1)
}

func (b *Uint64) Put(key []byte, value uint64) error {
	var buf bytes.Buffer

	encoder := cbor.Encoder(&buf)
	defer cbor.Return(encoder)

	encoder.MustEncode(&value)
	return b.Cursor.Put(key, buf.Bytes())
}

func (b *Uint64) ForEach(fn func([]byte, uint64) error) error {
	return ethdb.ForEach(b.Cursor, func(k, v []byte) (bool, error) {
		var value uint64
		decoder := cbor.Decoder(bytes.NewReader(v))
		defer cbor.Return(decoder)

		decoder.MustDecode(&value)
		return true, fn(k, value)
	})
}

type Int struct {
	ethdb.Cursor
}

func NewInt(b ethdb.Cursor) *Int {
	return &Int{b}
}

func (b *Int) Get(key []byte) (int, bool) {
	value, _ := b.Cursor.SeekExact(key)
	if value == nil {
		return 0, false
	}

	var v int
	decoder := cbor.Decoder(bytes.NewReader(value))
	defer cbor.Return(decoder)

	decoder.MustDecode(&v)
	return v, true
}

func (b *Int) Increment(key []byte) error {
	v, _ := b.Get(key)
	return b.Put(key, v+1)
}

func (b *Int) Decrement(key []byte) error {
	v, ok := b.Get(key)
	if !ok {
		// return ethdb.ErrNotFound
		return errors.New("not found key")
	}

	return b.Put(key, v-1)
}

func (b *Int) DecrementIfExist(key []byte) error {
	v, ok := b.Get(key)
	if !ok {
		return nil
	}

	return b.Put(key, v-1)
}

func (b *Int) Put(key []byte, value int) error {
	var buf bytes.Buffer

	encoder := cbor.Encoder(&buf)
	defer cbor.Return(encoder)

	encoder.MustEncode(&value)
	return b.Cursor.Put(key, buf.Bytes())
}

func (b *Int) ForEach(fn func([]byte, int) error) error {
	return ethdb.ForEach(b.Cursor, func(k, v []byte) (bool, error) {
		var value int
		decoder := cbor.Decoder(bytes.NewReader(v))
		defer cbor.Return(decoder)

		decoder.MustDecode(&value)
		return true, fn(k, value)
	})
}
